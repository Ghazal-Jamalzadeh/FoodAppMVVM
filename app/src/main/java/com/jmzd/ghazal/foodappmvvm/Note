تویی MVVM فقط از Flow - LiveData - Coroutine استفاده میکنیم چون خیلی خیلی ترکیب خوبی هستن

Server----------------------------------------------------------------------------------------------
هر جا که قبلا اب رتروفیت کار میکردیم و رسپانس را در  قالب Single میگرفتیم اون single پاک میشه و و همون Response دیفالت رتروفیت میشه
برای ترکی با کروتین تمام متدها تبدیل به ساسپند فانکشن میشن

بایندیینگ رو با اون روش جدید میریم که ویوهامون از دسترس خارج شن وقتی باید بشن

Kotlin delegates------------------------------------------------------------------------------------
در مورد این خط کد:
private val viewModel: HomeViewModel by viewModels()
ممکنه بپرسید چرا از inject برای تزریق ویومدل استفاده نمیکنیم مثل بقیه چیزها؟
ما زمانی که داریم از انوتیشن @HiltViewModel در ویومدل استفاده میکنیم
و از کاتلین دلیگیت by viewModels() استفاده میکنیم
خودش اون عملیات تزریق کردن رو برای ما انجام میده
در واقع این الان تزریق شده و من نیومدم از مساوی استفاده کنم

Extensions-------------------------------------------------------------------------------------------
توی پروژه نوت اپ mvp اومدیم برای اسپینرها اکستنشن نوشتیم
اینجا هم میخوایم همون کار رو بکنیم ولی باز جنرال تر و بهینه تر از قبلی
مثلا توی ورودی قبلی لیست استرینگ میگرفتیم توی ورودی
الان میخوایم دیتاتایپ مشخصی ندیم بهش
لایه های اختصاصی تری هم داره اسپینر فود اپ نسبت به نوت اپ که از پیش فرض ها استفاده میکنه

ورودی ها:
نیاز به یک لیست از آیتم ها داریم
همچنین نیاز به یک کال بک داربم که بفهمیم کدام آیتم سلکت شده

list: MutableList<out Any>
لیست را به این شکل تعریف میکنیم
هر دیتاتایپی را قول میکنه الان. از جمله:
string - int - char - double ....
[فکر کنم فقط دیتا تایپ های اصلی را قبول میکنه و فرقش با جنریک اینه. شایدم فرقی نداره؟]

callback: (String) -> Unit

flatten--------------------------------------------------------------------------------------------
   /*
        * نکته کاتلینی:
        * ما یک لیست نیاز داریم که حروف a تا z داخلش باشه ولی نمیخوایم دستی بنویسیم
        * listOf('A'..'Z')
        * اگر این را بنویسیم خروجی به شکل زیر خواهد بود:
        * a z (یک آیتم)
        * ولی ما میخوایم خروجی به شکل زیر باشه
        * a
        * b
        * c
        * ...
        * z
        * (آیتم های جدا از هم)
        * .flatten()
        * ابن کار را برای ما انجام میده و لیست را به ترتیب میسازه
        * */
        val filters = listOf('A'..'Z').flatten()
